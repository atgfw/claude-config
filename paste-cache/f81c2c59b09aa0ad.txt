# Workflow Breakdowns — Simple to Expert

---

## Workflow 1: Contact & Company Matcher

**Like I'm 5:**
When someone calls on the phone, the robot helper listens to their name and tries to figure out who they are. Sometimes people say their name in a funny way or the robot hears it wrong, so it uses a really smart brain to look at a big list of names and pick the one that matches best. It does the same thing with the company name. Once it finds the right person and the right company, it tells the other helpers so they know who called.

**Like I'm in High School:**
This workflow takes in caller information like a name, phone number, or email — stuff that might be garbled from a phone transcription — and tries to match it against real contacts and companies stored in a CRM system. It checks what info was provided, pulls lists of possible matches from the CRM based on whatever combination of name, email, or phone it has, and then hands those lists to an AI model. The AI uses custom prompts designed to handle misspellings, partial names, and phonetic guesses to pick the single best match. It outputs the matched contact ID, company ID, and names so downstream workflows know exactly who called.

**Like I'm a Junior Developer:**
This is a Rewst workflow bundle containing two sub-workflows. The primary sub-workflow (23 tasks) accepts optional string parameters for company name, contact first and last name, phone number, and email address, and outputs resolved contact_id, company_id, valid_company flag, contact_name, and company_name. The flow begins with a series of conditional branching tasks that check which input parameters are non-null — company_name_provided, email_address_provided, first_or_last_provided, full_name_provided, phone_number_provided — and routes accordingly to various CRM query tasks like potential_companies_from_provided, potential_contacts_from_email_address, potential_contacts_from_phone, and so on. These tasks query ConnectWise PSA using filtered API calls to retrieve candidate lists. Once candidates are assembled, the flow invokes the second sub-workflow — a reusable 14-task AI Chat Completion wrapper — passing Jinja-rendered prompt templates to GPT-5-mini (via Azure AI or OpenAI, switchable by a boolean flag). There are four prompt templates: one for fuzzy-matching a transcribed company name against a candidate list, one for matching a contact from a company's contact list, one for matching a contact when only a name is known, and a ticket categorization template. The AI sub-workflow handles token counting, model routing between Azure and OpenAI endpoints, JSON response parsing with conditional branches for expect_json and Expect_array flags, retry logic with 20-second delays on rate limits, and explicit failure on request-too-large errors. The AI returns structured JSON with the best match ID, and the parent workflow uses that to set context variables and return the resolved identities.

**Like I'm a Senior/Expert Developer:**
This bundle exports a two-tier Rewst automation designed as a callable sub-workflow for AI-assisted CRM entity resolution in a multi-tenant MSP context. The outer workflow implements a combinatorial input-gating pattern: five optional string parameters (company_name, contact_first_name, contact_last_name, contact_phone_number, contact_email_address) are evaluated through Jinja2 conditional transitions (`{{ CTX.company_name is not none }}`, `{{ (CTX.contact_first_name is not none) or (CTX.contact_last_name is not none) }}`, etc.) to determine the optimal query strategy. Depending on which fields are populated, the workflow fans out to ConnectWise PSA API calls with dynamically constructed query_params — filtering by company ID, contact name fragments, email, or phone — to build candidate sets. These candidates are then passed into an AI matching stage that invokes the inner 14-task sub-workflow. That sub-workflow is a generic LLM completion orchestrator accepting a Jinja template reference, azure_ai boolean toggle, max_tokens, expect_json, and Expect_array parameters. It builds the prompt from the template, counts tokens to determine if the payload fits within model limits, routes to either Azure AI or OpenAI completion endpoints with identical JSON request bodies (model: gpt-5-mini, temperature: 1, optional json_object response format), and handles response parsing through branching conditions that check `CTX.AI_Response.choices|d | length > 0` with further branching on whether JSON parsing is expected. Rate-limit 429 responses trigger a 20-second retry loop, while payload-too-large errors route to an explicit failure path. The four embedded prompt templates are purpose-built for entity resolution: the company matcher instructs the model to select a single best company_id from a potential_companies array given a possibly misspelled transcription, with strict instructions to return null rather than guess; the contact matchers operate similarly but additionally incorporate phonetic and acronym matching heuristics; and a fourth template handles MSP ticket categorization into a hierarchical type/subtype taxonomy from a provided type_key JSON structure. The outer workflow consumes the AI's structured JSON response, checks `CTX.ai_company.ai_response.company_id != none` with fallback paths that attempt alternative matching strategies before ultimately setting five output context variables. The multi-path fallback design — from direct match to AI-assisted fuzzy match to broader candidate pool expansion — ensures high resolution rates even with degraded voice-to-text input quality typical of telephony transcription pipelines.

---

## Workflow 2: Call Journaling Core

**Like I'm 5:**
When a technician at the computer repair shop gets a phone call, this robot helper listens to the whole conversation. After the call is done, it figures out who called and what they were talking about. Then it looks through all the open repair tickets to see if the call was about something that's already being worked on. If it finds a match, it writes a note on that ticket saying what happened in the call. It also sends a message to the technician on Microsoft Teams with a nice card showing all the details.

**Like I'm in High School:**
This workflow is triggered by an incoming webhook — likely from a phone system or voice AI agent after a call ends. It receives a payload containing the call transcript, caller identity info (contact ID, company ID, member/engineer ID), and metadata. The flow first checks if a transcript exists, then resolves the assigned engineer by looking up their ConnectWise member profile. It runs through a testing gate that limits execution to specific member IDs during rollout. From there, it determines whether a contact and company are already identified or need lookup, queries ConnectWise for open service tickets scoped by contact, company, or assigned engineer, and uses AI to determine whether any of those tickets match the call's topic. If a single candidate ticket is found, an AI prompt compares the transcript against that ticket's notes to verify it's truly a match and whether the call represents a new issue or a follow-up. If multiple candidate tickets exist, a different AI prompt reviews them all and selects the best match. Once a ticket is confirmed, the workflow writes a journal note to the ticket in ConnectWise, optionally updates the ticket's initial description if the AI determines the call is the first report of the issue, logs a sales activity for call tracking, stores several organization variables (the outgoing message, the raw call body, and a review flag), resolves the engineer's Teams conversation ID via Microsoft Graph, and sends an adaptive card to their Teams chat summarizing the call, the matched ticket, and the journal entry.

**Like I'm a Junior Developer:**
This bundle contains five sub-workflows working in concert. The main orchestrator (44 tasks, triggered by webhook with a workflow_input parameter) implements the full call-to-ticket journaling pipeline. BEGIN_HERE routes to interupt_handler, which checks if workflow_input is populated (incoming call data) or if this is a cold start. The flow then hits initial_call_handler, which gates on `CTX.body.transcription is defined and CTX.body.transcription is not none` — no transcript means the flow terminates at no_transcript. Member_Handler resolves the engineer via get_member using CTX.member_id against ConnectWise PSA's member endpoint, then TEMPORARY_TESTING restricts execution to a whitelist of member IDs (231, 233, 257, 230, 244, 185) for phased rollout. bypass_Handler checks if contact_id is pre-populated and routes either to direct contact lookup (connect_wise_psa_get_contact_1) or into the standard_Handler branching tree. The standard_Handler tasks implement a ticket discovery hierarchy: if contact_id is known, query get_contact_w_engineer_tickets (scoped by contact + engineer + board), falling back to get_contact_tickets (contact + board), then get_company_tickets (company + board), then get_engineer_tickets (engineer + board only). Each query step checks ticket count — exactly one routes to single_ticket_verification (which calls the AI sub-workflow with a comparison prompt template), multiple routes to multi_ticket_verification (AI sub-workflow with a multi-ticket selection prompt), and zero routes to the next broader query. The AI sub-workflows call the reusable 14-task Chat Completion wrapper with azure_ai=False, expect_json=True, Expect_array=True. single_ticket_verification evaluates the AI response's ticket_matches_call_issue boolean and call_is_new_issue flag, routing to note_routing_handler if matched or falling through to broader searches. multi_ticket_verfication checks if selected_ticket_id is defined and non-null. Once a ticket is confirmed via get_all_notes (fetching detailDescriptionFlag=true notes), the workflow calls transforms_append_with_items_results to merge notes onto ticket objects, then proceeds to note_routing_handler which gates on member department (Tier 1/2/3) to determine note type. Journal notes are written via call_log_internal or log_call_internal (ConnectWise service ticket notes API), initial_description is conditionally updated via the update_initial_desc sub-workflow call (11-task flow that fetches existing notes, determines if the initial description should be overwritten or preserved based on note type and character count thresholds, and updates via PSA API). Three rewst_create_organization_variable tasks persist call_journal_msg_{activity_id}, call_journal_data_{activity_id}, and journal_review_{activity_id} as org variables for later retrieval. The workflow then calls workflows_return_patch_personal_convo_id (7-task sub-workflow that resolves a Teams user via Microsoft Graph by email, checks for existing conversation org variables, and returns conversation_id/found_convo/found_user), and finally invokes workflows_microsoft_bot_framework_send_message_v_1_0_1 (33-task Teams Bot Framework sub-workflow) to deliver the adaptive card. That Teams sub-workflow handles bot and Graph access token management with caching in org variables, token expiry checks via Jinja datetime parsing, app catalog installation, typing indicators, and multiple message types including adaptive cards, direct messages, and activity notifications.

**Like I'm a Senior/Expert Developer:**
This bundle is a production-grade Rewst automation implementing an end-to-end call journaling pipeline for an MSP (Applied Technology Group) that ingests post-call payloads from a telephony/voice-AI integration, performs AI-assisted ticket correlation against ConnectWise PSA, writes structured journal entries, and delivers interactive notifications via Microsoft Teams Bot Framework. The architecture comprises five sub-workflows with clear separation of concerns. The main orchestrator (44 tasks, webhook-triggered) implements a progressive ticket resolution strategy using a hierarchical narrowing pattern: it begins with the most specific query scope (contact + assigned engineer + board filter) and progressively widens to contact-only, company-only, then engineer-only queries against ConnectWise PSA's service ticket API, using Jinja-templated conditions strings like `contact/id = {{CTX.contact_id}} and closedFlag = false and {{CTX.board_id_list}} and resources contains "{{CTX.member.identifier}}"`. The board_id_list variable provides multi-board filtering, and each query stage branches on `CTX.potential_tickets|count` — exactly one triggers single-ticket AI verification, multiple triggers multi-ticket AI selection, and zero cascades to the next broader scope. The AI verification layer uses two distinct prompt strategies: the single-ticket template instructs GPT-5-mini to compare a specific ticket's notes against the call transcript, returning a structured JSON with ticket_matches_call_issue (boolean), call_is_new_issue (boolean for first-report detection), and initial_description_from_call (extracted description for new issues); the multi-ticket template receives all candidate tickets with their notes (merged via transforms_append_with_items_results using a base_list/attribute_name pattern) and returns either a selected_ticket_id or null with explicit instructions to prefer null over weak matches. The prompt engineering is sophisticated — templates explicitly guard against false positives from overlapping contact/company/resource associations, instruct the model to weight issue-description alignment over metadata proximity, and enforce null-preference behavior to avoid phantom ticket matches. Post-correlation, the note_routing_handler implements department-aware journal note formatting by gating on `CTX.member.defaultDepartment.name` across Tier 1/2/3, and the journaling sub-workflow (11 tasks) handles initial description management with nuanced logic: it fetches all notes with detailDescriptionFlag=true, locates the initial description note, and conditionally overwrites (if the existing note is under 50 characters and is a TicketNote type) or preserves (appending new content) based on `CTX.initial_desc_note.text|count < 50 and CTX.initial_desc_note.noteType == "TicketNote"`. Three organization variables are persisted per call using activity_id-keyed names (call_journal_msg, call_journal_data, journal_review), enabling the interactive response handler in Workflow 3 to retrieve full call context without re-processing. The Teams messaging sub-workflow (33 tasks) implements a full Bot Framework v4 integration pattern with OAuth2 token lifecycle management — bot access tokens and Graph access tokens are cached as org variables, with Jinja-based expiry validation that parses stored YAML timestamps and compares against current time. It handles bot-to-team installation via app catalog lookup, supports multiple outgoing message types (standard text, adaptive cards with update capability, direct messages, activity feed notifications with bulk sending), implements typing indicators with configurable delays, and includes an n8n webhook bridge (await_n8n_response) for external processing scenarios. The conversation resolution sub-workflow (7 tasks) chains Microsoft Graph user lookup by email to org variable-based conversation ID caching, establishing the personal chat channel for adaptive card delivery. The phased rollout mechanism via TEMPORARY_TESTING with hardcoded member ID whitelisting, combined with the connect_wise_psa_create_sales_activity call logging for non-ticket-matched calls, indicates this is a production system in controlled deployment with full audit trail requirements.

---

## Workflow 3: Call Journaling + Interactive Ticket Response

**Like I'm 5:**
This is just like the last robot helper, but now when the technician gets the Teams message with the pretty card about the phone call, they can actually click buttons on it! They can say "yes, open a new ticket" or type in a ticket number if they already know which one it should go to. When they click the button, the robot reads back all the saved information about the call, looks up the ticket they picked, grabs all the notes from that ticket, and then does the journaling work — writing the call notes onto that ticket. Then it updates the card in Teams so it shows a green checkmark instead of the buttons, so everyone knows it's been handled.

**Like I'm in High School:**
This workflow bundle is nearly identical to Workflow 2 — it shares the same main 44-task call handler, the same Teams Bot messaging sub-workflow, the same AI completion wrapper, the same ticket note journaling sub-workflow, and the same conversation ID resolver. The key addition is a sixth sub-workflow (15 tasks) that handles interactive responses from the adaptive card sent to Teams. When an engineer clicks a button or submits a ticket number on the card, this response handler fires. It retrieves the stored organization variables (the original call message, raw call body, and review data) using the reply_to_id from the card interaction, determines whether the engineer chose to open a new ticket or specified an existing ticket number, fetches the ticket details and all its notes from ConnectWise, re-invokes the main call journaling flow with the resolved ticket data, sends a confirmation message back to the Teams conversation, and updates the original adaptive card to reflect the completed action.

**Like I'm a Junior Developer:**
This bundle exports six sub-workflows — the same five from Workflow 2 plus a new 15-task Ticket Response Handler sub-workflow. That sub-workflow accepts parameters open_ticket (string, "yes"/"no"), reply_to_id (the Teams activity ID of the original adaptive card), ticket_number (optional, engineer-specified), conversation_id, and user_aaadObjectId. The flow starts at begin_here, which routes to rewst_rewst_list_integrations_for_organization_1 to validate the ConnectWise integration, then to three sequential rewst_get_organization_variable calls that retrieve call_journal_msg_{reply_to_id}, call_journal_data_{reply_to_id}, and journal_review_{reply_to_id} — the same org variables that the main workflow persisted. If the journal_review variable lookup fails (rewst_get_organization_variable_2 with `when={{ FAILED }}`), it routes to no_tracker_var_found which handles the edge case. The response_handler task evaluates `CTX.open_ticket == "yes" or (CTX.ticket_number is defined and CTX.ticket_number is not none)` to branch between ticket-linked and non-ticket paths. The ticket path hits ticket_field_filled which checks if a ticket number was provided, then connect_wise_psa_get_service_ticket (using `CTX.ticket_number|trim|int` for safe parsing) followed by connect_wise_psa_list_all_service_ticket_notes to retrieve all notes with fields id, ticketId, text, member/name, contact/name. The flow then calls workflows_call_journaling_flow, passing `{'body': '{{CTX.initial_body}}', 'notes': '{{CTX.notes}}', 'found_ticket': '{{CTX.ticket}}'}` — effectively re-entering the main journaling pipeline with a pre-resolved ticket. Finally, it sends a confirmation via workflows_workflows_microsoft_bot_framework_send_message_v_1_0_1_1 and calls update_card twice (two separate tasks with identical inputs) to replace the original adaptive card's interactive elements with a completed state, using the Teams Bot Framework sub-workflow with the reply_to_id as the activity_id for card replacement.

**Like I'm a Senior/Expert Developer:**
This bundle extends Workflow 2 with a closed-loop interactive feedback mechanism, adding a 15-task Ticket Response Handler that transforms the system from a one-way notification pipeline into a bidirectional human-in-the-loop automation. The architectural pattern here is event-sourced state reconstitution: when the main workflow completes its initial processing, it persists three org variables keyed by activity_id (the Teams adaptive card's unique activity identifier), effectively creating a lightweight event store. When the engineer interacts with the adaptive card — either selecting "open ticket" or providing a ticket number — the response handler reconstitutes the full call context by retrieving those three org variables using reply_to_id as the correlation key. This avoids re-triggering the telephony integration or re-processing the transcript, instead hydrating CTX.initial_body (the original call payload), CTX.outgoing_msg (the formatted journal message), and CTX.check_var (the review metadata) from persisted state. The flow then performs its own ConnectWise resolution: connect_wise_psa_get_service_ticket with `CTX.ticket_number|trim|int` (defensive parsing against whitespace in user input), followed by a full notes retrieval. Rather than duplicating journaling logic, it re-invokes the main call journaling flow as a sub-workflow via workflows_call_journaling_flow, passing the pre-resolved ticket object, notes array, and original call body — this creates a recursive workflow invocation pattern where the response handler feeds back into the same pipeline but bypasses the ticket discovery and AI matching stages since the ticket is already engineer-confirmed. The dual update_card tasks (both targeting the same reply_to_id/conversation_id with identical inputs) likely handle both the card update and a state transition notification, using the Teams Bot Framework sub-workflow's adaptive card update capability (which sends a PUT to the Bot Framework activity endpoint rather than a POST, replacing the card in-place). The rewst_get_organization_variable_2 failure path to no_tracker_var_found handles the race condition where org variables may have been cleaned up or the card interaction arrives after a TTL expiration, providing graceful degradation rather than a hard failure. The ms_tenant_id propagation through all Teams sub-workflow invocations ensures correct multi-tenant routing in the MSP's managed environment, where each client organization has its own Azure AD tenant and the bot must authenticate against the correct tenant for each message delivery. The teams_app_catalog_id (ef7ea9ea-ae5b-4d3d-aa7b-4ad083525429) is hardcoded across all Teams messaging invocations, indicating a single registered bot application shared across tenants via the Teams app catalog, with per-tenant installation handled dynamically by the install_bot_to_team task in the messaging sub-workflow.